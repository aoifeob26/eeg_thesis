---
title: "Untitled"
output: html_document
date: "2025-03-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(fda)
library(fda.usc)
library(caret)
library(tidyverse)
library(refund)
library(glmnet)

# Load data
firsttrial <- readRDS("firsttrial_data.rds")

# Set up Fourier basis
nbasis <- 21  # Adjust as needed
rangeval <- c(min(data$time), max(data$time))
fourier_basis <- create.fourier.basis(rangeval, nbasis)

# Convert data into functional data object (fd)
fd_par <- fdPar(fourier_basis)
data_fd <- Data2fd(argvals = data$time, y = as.matrix(data[ , -c(1:2)]), fdParobj = fd_par)

# Perform FPCA with 95% variance explained
fpca_result <- pca.fd(data_fd, nharm = NULL)
cumvar <- cumsum(fpca_result$values) / sum(fpca_result$values)
nharm_95 <- which(cumvar >= 0.95)[1]  # Select the number of harmonics that explain 95% variance
fpca_result <- pca.fd(data_fd, nharm = nharm_95)

# Extract scores
scores <- fpca_result$scores

# Combine scores with metadata
fpca_scores <- cbind(data[, c("subject", "condition")], scores)

# Filter for alcoholic group
fpca_scores_alc <- fpca_scores[data$condition == "a", ]

# Train-test split
set.seed(123)
trainIndex <- createDataPartition(fpca_scores_alc$condition, p = 0.8, list = FALSE)
train_data <- fpca_scores_alc[trainIndex, ]
test_data <- fpca_scores_alc[-trainIndex, ]

# Train models
model_fp1 <- train(condition ~ PC1, data = train_data, method = "glm", family = "binomial")
model_fp2 <- train(condition ~ PC2, data = train_data, method = "glm", family = "binomial")
model_fp1_fp2 <- train(condition ~ PC1 + PC2, data = train_data, method = "glm", family = "binomial")

# Lasso Regularization Model on FP1
predictors_fp1 <- as.matrix(train_data[, "PC1", drop = FALSE])
response <- as.factor(train_data$condition)
lasso_model_fp1 <- cv.glmnet(predictors_fp1, response, alpha = 1, family = "binomial")
predictions_lasso_fp1 <- predict(lasso_model_fp1, newx = as.matrix(test_data[, "PC1", drop = FALSE]), s = "lambda.min", type = "class")
conf_matrix_lasso_fp1 <- confusionMatrix(factor(predictions_lasso_fp1, levels = levels(response)), test_data$condition)

# Lasso Regularization Model on FP2
predictors_fp2 <- as.matrix(train_data[, "PC2", drop = FALSE])
lasso_model_fp2 <- cv.glmnet(predictors_fp2, response, alpha = 1, family = "binomial")
predictions_lasso_fp2 <- predict(lasso_model_fp2, newx = as.matrix(test_data[, "PC2", drop = FALSE]), s = "lambda.min", type = "class")
conf_matrix_lasso_fp2 <- confusionMatrix(factor(predictions_lasso_fp2, levels = levels(response)), test_data$condition)

# Lasso Regularization Model on FP1 + FP2
predictors_fp1_fp2 <- as.matrix(train_data[, c("PC1", "PC2")])
lasso_model_fp1_fp2 <- cv.glmnet(predictors_fp1_fp2, response, alpha = 1, family = "binomial")
predictions_lasso_fp1_fp2 <- predict(lasso_model_fp1_fp2, newx = as.matrix(test_data[, c("PC1", "PC2")]), s = "lambda.min", type = "class")
conf_matrix_lasso_fp1_fp2 <- confusionMatrix(factor(predictions_lasso_fp1_fp2, levels = levels(response)), test_data$condition)

# Predict on test set
pred_fp1 <- predict(model_fp1, test_data)
pred_fp2 <- predict(model_fp2, test_data)
pred_fp1_fp2 <- predict(model_fp1_fp2, test_data)

# Evaluate
conf_matrix_fp1 <- confusionMatrix(pred_fp1, test_data$condition)
conf_matrix_fp2 <- confusionMatrix(pred_fp2, test_data$condition)
conf_matrix_fp1_fp2 <- confusionMatrix(pred_fp1_fp2, test_data$condition)

print(conf_matrix_fp1)
print(conf_matrix_fp2)
print(conf_matrix_fp1_fp2)
print(conf_matrix_lasso_fp1)
print(conf_matrix_lasso_fp2)
print(conf_matrix_lasso_fp1_fp2)

```

